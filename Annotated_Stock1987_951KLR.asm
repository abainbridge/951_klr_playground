// TODO:
// - Is the trigger signal from the DME on pin 4 (pin 24 of the KLR connector)

// Microcontroller specs:
// 128 bytes of RAM
// 4096 bytes of external EPROM (used for program and data)
// 11 MHz XTAL. There are 15 ticks of this clock per CPU "cycle". Most instructions take 1 "cycle", some take 2.
// So the CPU effectively runs at 733 kHz.

// The way we configure the timer causes an interrupt every 87us if about 1500 RPM or 170us if above 750 RPM.

// Inputs:
// Reset (pin 4) - Trigger signal from DME (80 degrees before TDC)
// Ext int (pin 6) - Ignition signal from DME
// T1 (pin 39) - Ignition signal from DME

// At 850 RPM
// 
// Time (ms)      0                35               70       
// 
// Reset     _____|________________|________________|________________ One spike per cylinder fire.
// (trigger)                                                          Two per crank revolution.
//                     ___              ___              ___  
// T1        _________|   |____________|   |____________|   |________ 
// (ignition)

// Register bank 0 - Used for interrupt context
// r0 - Holds 24h at start of interrupt. 24h is scratch space to store the normal-context's accumulator
// r2 - A count of number of times timer interrupt fired.
// r3 - used as an input to the 8-bit multiply function
// r5 - Decremented every interrupt. When reaches 0
// r6 - engine speed represented as the number of timer interrupts since the last reset. Actually
//      it is a count that is initialized to 0 at reset and counts _down_ each interrupt.
// r7 - the current timer period. Actually it is the value the timer/event-counter register
//      is re-initialized to every time the timer interrupt happens. r7 is initialized to 0xfc
//      in the boot code, and then left/right shifted occasionally depending on the RPM. In practice
//      it has a value of 0xfe when the RPM is above 1500 RPM and 0xfc otherwise.

// Register bank 1 - Used for normal context

// Global variables
// 24h - engine_speed???
// 2fh - raw knock sensor reading?
// 33h - blink code
// 38h - scratch space for interrupt routines to stash the non-interrupt context's accumulator
// 39h - +V value read by the ADC
// 3ah - throttle position in degrees
// 3ch - raw throttle position sensor
// 44h - RPM range. 64 means 0-1863 RPM, 0 means over 6386 RPM.
// 45h - current maximum knock threshold (looked-up from map based on current RPM. But map is all the same value of 10)
// 46h - integrated knock value read by ADC
// 7ah - current knock threshold value for the cylinder that fired in the previous cycle

// Reset behaviour (section 2.1.12 of the MCS-48 manual)
// - PC set to zero
// - Stack Pointer set to zero
// - Reg bank 0 and mem bank 0 selected.
// - Interrupts are disabled
// - All port latches initialized to 1
// - Stops time (but does NOT zero the timer counter).
// - Overflow flag is reset
// - Clears F0, F1 and the Timer flag

// Start the timer. This resets the internal 32-cycle counter. As a result, the
// timer will tick in 32 cycles time.
0x00 strt t
0x01 jmp  $0077

// ext int routine
0x03 sel  rb0
0x04 dis  i
0x05 jmp  $030E

// timer int routine
0x07 sel  rb0
0x08 mov  @r0,a   // Store the accumulator. First time in r0=0x38. Next time it is 0x7c. Weird.
0x09 mov  a,r7
0x0a mov  t,a
0x0b djnz r6,$0010
0x0d inc  r6
0x0e inc  r6
0x0f stop tcnt
0x10 jnt1 $001A
0x12 en   i
0x13 djnz r3,$001A // r3 was zeroed at end of startup code.
0x15 inc  r3
0x16 anl  p2,#$BF // Clear bit 6 of port 2. (Ignition output inversed)
0x18 orl  p2,#$80 // Set bit 7 of port 2. (Ignition output)

0x1a djnz r2,$0036// r2 was set to 0xfc early in the startup code, but then zeroed near the end.

0x1c mov  r0,#$26
0x1e mov  a,@r0
0x1f inc  a
0x20 mov  r2,a
0x21 mov  a,r7
0x22 rrc  a
0x23 xch  a,r2
0x24 rlc  a
0x25 xch  a,r2
0x26 rrc  a
0x27 jnc  $0023
0x29 djnz r2,$0029
0x2b orl  p2,#$40
0x2d anl  p2,#$7F
0x2f djnz r5,$0032
0x31 inc  r5
0x32 mov  r0,#$38
0x34 jmp  $005E
0x36 djnz r5,$0063

// Only execute this section every 60ms (?)
0x38 mov  r0,#$40
0x3a mov  a,r7
0x3b inc  @r0
0x3c jb1  $003F
0x3e inc  @r0
0x3f mov  a,@r0
0x40 inc  r0
0x41 jb2  $004E
0x43 mov  a,@r0
0x44 jz   $004A
0x46 anl  p1,#$EF
0x48 jmp  $0054
0x4a dec  r0
0x4b mov  @r0,#$FF // mem[0x40] = 0xff
0x4d inc  r0
0x4e mov  a,@r0
0x4f cpl  a
0x50 add  a,#$C1
0x52 orl  p1,#$10
0x54 mov  r5,a
0x55 dec  r0
0x56 mov  a,@r0
0x57 swap a
0x58 xchd a,@r0
0x59 anl  a,#$77
0x5b mov  @r0,a
0x5c mov  r0,#$38
0x5e djnz r4,$0061
0x60 inc  r4
0x61 mov  a,@r0
0x62 retr

0x63 djnz r4,$0061
0x65 orl  p1,#$80
0x67 mov  r0,#$2C
0x69 mov  a,@r0
0x6a inc  @r0
0x6b mov  r4,#$2
0x6d call $040B
0x6f mov  r0,#$38
0x71 mov  a,@r0
0x72 retr         // Has side-effect of restoring the previous register bank setting
// END of timer int routine


// Reset/Trigger routine
0x73 anl  p2,#$47 // Clear ignition output, knock sensor integrator reset and LED
0x75 jmp  $007B

// reg bank = 0
entry_point:
0x77 jnt1 $0073   // Jump if ignition input is low
0x79 anl  p2,#$87 // Clear ignition output inversed, knock sensor integrator reset and LED

0x7b mov  r0,#$25
0x7d mov  r1,#$21
0x7f mov  a,@r1
0x80 mov  @r0,a   // _25 = _21

// 26h - Copy of 20h before trigger processed
// 20h - Copy of 28h before trigger processed
// 21h - Copy of 29h before trigger processed

// _26 = _20
0x81 inc  r0      // r0 = 26
0x82 dec  r1      // r1 = 20
0x83 mov  a,@r1
0x84 mov  @r0,a

// _20 = _28
0x85 mov  r0,#$28
0x87 mov  a,@r0
0x88 mov  @r1,a

// _21 = _29
0x89 inc  r0      // r0 = 29
0x8a inc  r1      // r1 = 21
0x8b mov  a,@r0
0x8c mov  @r1,a

// timer counter = 0xfc. The timer hardware will increment "t" every 32 cycles.
// When it overflows back to 0, the timer interrupt will fire.
// 38h is space for the accumulator to be stored by the interrupt routine
0x8d mov  r0,#$38
0x8f mov  a,#$FC
0x91 mov  t,a
0x92 mov  r2,a    // r2 = 0xfc

0x93 inc  r5      // r5 = 1 on boot
0x94 mov  r1,#$40 // I wonder what 0x40 points to. Obviously zero on boot.
0x96 mov  a,@r1
0x97 djnz r5,$09C // r5 is zero on boot, so no jump
0x99 inc  r5      // put r5 back to 1 on boot
0x9a swap a
0x9b xchd a,@r1
0x9c jb2  $00A0
0x9e anl  p1,#$EF
0xa0 call $0325   // does r4 = mem[24h]
0xa2 en   tcnti
0xa3 mov  r1,#$3C
0xa5 movx a,@r1   // On first execute of this instruction, ADC channel 7 (TPS) is selected
0xa6 xch  a,@r1
0xa7 inc  r1
0xa8 mov  @r1,a
0xa9 mov  r1,#$3E
0xab mov  a,@r1
0xac cpl  a
0xad mov  r1,#$3A
0xaf add  a,@r1
0xb0 jc   $00B4
0xb2 anl  p1,#$DF // 1101_1111 - Clear full load signal to DME
0xb4 mov  r1,#$24
0xb6 clr  a
0xb7 xch  a,r6    // Put r6 (num timer firings) in accumulator and clear r6.
0xb8 cpl  a
0xb9 mov  @r1,a
0xba mov  a,@r1
0xbb add  a,#$1A
0xbd jnc  $00CF
0xbf mov  a,r7
0xc0 clr  c
0xc1 rlc  a
0xc2 mov  r7,a
0xc3 inc  r1

// r1 == 25
// Say _25 was 100
0xc4 mov  a,@r1
0xc5 clr  c       // Clear carry bit in PSW
0xc6 rrc  a       // Rotate accumulator right. Top bit gets zero from carry bit.
0xc7 mov  @r1,a   // _25 is now 50
0xc8 dec  r1      // r1 := 24h
0xc9 mov  a,r1    // a := 24h
0xca cpl  a       // a := dbh == 0b1101_1011

// We get to about here before the timer interrupt fires for the first time.
0xcb jb4  $00C4

0xcd call $0325
0xcf mov  r1,#$24
0xd1 mov  a,@r1
0xd2 add  a,#$92
0xd4 cpl  f1
0xd5 jc   $00EF   // If _24 + 92h > 256 jump 0ef
0xd7 add  a,#$41
0xd9 jc   $00DC   // If _24 + d3h > 256 jump 0dc
0xdb cpl  f1
0xdc mov  a,r7
0xdd jb1  $00EF
0xdf clr  c
0xe0 cpl  c
0xe1 rrc  a
0xe2 mov  r7,a
0xe3 inc  r1

// r1 == 25 again, same loop logic as above
0xe4 mov  a,@r1
0xe5 clr  c
0xe6 rlc  a
0xe7 mov  @r1,a
0xe8 dec  r1
0xe9 mov  a,r1
0xea cpl  a
0xeb jb4  $00E4

0xed call $0325
0xef mov  r1,#$31
0xf1 inc  @r1
0xf2 jmp  $0102
0xf4 nop
0xf5 nop
0xf6 nop
0xf7 nop
0xf8 nop
0xf9 nop
0xfa nop
0xfb nop
0xfc nop
0xfd nop
0xfe movp a,@a
0xff ret

// Increment _2c until the bottom 3 bits are zero
0x100 nop
0x101 inc  @r1       // r1 = 0x2c because we only get here after looping

0x102 mov  r1,#$2C
0x104 mov  a,@r1
0x105 anl  a,#$7
0x107 jnz  $0101

0x109 mov  r1,#$33
0x10b mov  a,@r1
0x10c jz   $0137

0x10e mov  a,r7
0x10f jb1  $0135
0x111 mov  r1,#$2C
0x113 mov  a,@r1
0x114 jb7  $0137
0x116 mov  r1,#$32
0x118 jnz  $0127
0x11a mov  a,@r1
0x11b jnz  $0125
0x11d inc  r1
0x11e mov  a,@r1
0x11f dec  r1
0x120 add  a,#$A8
0x122 swap a
0x123 add  a,#$19
0x125 dec  a
0x126 mov  @r1,a
0x127 mov  a,@r1
0x128 anl  a,#$F
0x12a jnz  $0131
0x12c mov  a,@r1
0x12d swap a
0x12e jb3  $0123
0x130 mov  @r1,a
0x131 add  a,#$FD
0x133 jnc  $0137
0x135 orl  p2,#$10
0x137 mov  r1,#$27
0x139 mov  a,r1
0x13a xch  a,@r1
0x13b add  a,#$D9
0x13d jnz  $0146
0x13f mov  a,r7
0x140 clr  c
0x141 rlc  a
0x142 jc   $0140
0x144 jz   $0148
0x146 mov  r7,#$F0
0x148 sel  rb1
0x149 mov  r1,#$24
0x14b mov  a,@r1
0x14c mov  r6,a
0x14d sel  rb0
0x14e mov  a,r7
0x14f jb2  $01B1
0x151 jb3  $016A
0x153 orl  p2,#$10

0x155 mov  r1,#$7F
0x157 mov  @r1,#$2F
0x159 dec  r1
0x15a mov  @r1,#$46  // mem[0x7e] = 0x46
0x15c dec  r1
0x15d mov  @r1,#$31
0x15f dec  r1
0x160 mov  @r1,#$34  // mem[0x7c] = 0x34

// Zero memory from 0x28 to 0x7c
0x162 dec  r1
0x163 mov  @r1,#$0
0x165 mov  a,r1
0x166 xrl  a,#$28
0x168 jnz  $0162

0x16a mov  a,#$FF
0x16c orl  p1,#$10   // Cycling valve PWM enable
0x16e mov  r1,#$2E
0x170 mov  @r1,a
0x171 mov  r1,#$30
0x173 mov  @r1,a
0x174 mov  r1,#$34
0x176 mov  @r1,#$6
0x178 inc  r1
0x179 mov  @r1,a
0x17a inc  r1
0x17b mov  @r1,a
0x17c mov  r1,#$39 // TPS supply voltage
0x17e mov  @r1,#$C8 // 39h <- 200
0x180 mov  a,#$77 // 119
0x182 mov  r1,#$3B
0x184 mov  @r1,a // 3B <- 119
0x185 mov  r1,#$3C
0x187 mov  @r1,a // 3C <- 119
0x188 inc  r1
0x189 mov  @r1,a // 3D <- 119
0x18a inc  r1
0x18b mov  @r1,a
0x18c mov  r1,#$2C
0x18e mov  @r1,#$0
0x190 mov  r1,#$2A
0x192 mov  @r1,#$3F
0x194 inc  r1
0x195 mov  @r1,#$1B
0x197 mov  r1,#$22
0x199 mov  @r1,#$A
0x19b inc  r1
0x19c mov  @r1,#$2
0x19e clr  a
0x19f mov  r2,a
0x1a0 mov  r3,a
0x1a1 dis  i
0x1a2 sel  rb1       // I guess this means we've finished setting things up for the interrupt routines
0x1a3 call $0336

// Loop while ignition signal input is low.
0x1a5 orl  p2,#$40   // Set bit6 in port 2
0x1a7 anl  p2,#$7F   // Clear bit 8 in port 2
0x1a9 jnt1 $01A5

0x1ab anl  p2,#$BF
0x1ad orl  p2,#$80
0x1af jmp  $01A9
// END of trigger/reset routine

// timing delay calculation
0x1b1 sel  rb1
0x1b2 mov  r1,#$73
0x1b4 mov  a,@r1
0x1b5 mov  r1,#$3F
0x1b7 add  a,@r1
0x1b8 mov  r3,a
0x1b9 call $0300
0x1bb clr  c
0x1bc rrc  a
0x1bd mov  r1,#$29
0x1bf mov  @r1,a
0x1c0 mov  a,r3
0x1c1 rrc  a
0x1c2 swap a
0x1c3 anl  a,#$F
0x1c5 dec  r1
0x1c6 mov  @r1,a
0x1c7 jmp  $0200
// END of timing delay calculation

// BIG GAP
0x1fe movp a,@a
0x1ff ret

// Blink code calculation
0x200 mov  r1,#$33
0x202 mov  a,@r1
0x203 add  a,#$EE
0x205 jnc  $0215
0x207 add  a,#$EC
0x209 jc   $0215
0x20b mov  r0,#$73
0x20d mov  @r0,#$2D
0x20f mov  r0,#$31
0x211 mov  @r0,#$2
0x213 jmp  $0243
0x215 mov  r0,#$44
0x217 mov  a,#$E4
0x219 add  a,@r0
0x21a jc   $022F     // If mem[0x44] >= 28 jump 0x22f, ie if RPM is more than
0x21c mov  r0,#$2F
0x21e mov  a,#$89
0x220 add  a,@r0     // If mem[0x2f] >= 137 set carry 
0x221 mov  r2,#$22   // $22 is the faulty knock sensor blink code
0x223 jc   $022A     // If carry jump 0x22a
0x225 dec  r2        // $21 is the engine too noisy blink code
0x226 mov  a,#$FA
0x228 add  a,@r0
0x229 cpl  c
0x22a inc  r0
0x22b call $032A
0x22d jmp  $0243
0x22f mov  r0,#$43
0x231 mov  a,@r0
0x232 cpl  a
0x233 add  a,#$18
0x235 jc   $0243
0x237 mov  r0,#$52
0x239 mov  a,@r0 // load current MAP sensor pressure into a
0x23a add  a,#$BF // add 191
0x23c cpl  c // c=1 means an error, 0 means no error (checked in 0x32a/0x32c). So it's an error if the add
             // did not carry, iow the MAP pressure value was <=64, that is ~54kpa or -7.8psi (that is 45kpa
             // or 6.5psi before 10 was added in the ADC routine)
0x23d mov  r2,#$33 // this appears to be setting the BCD for a bad MAP sensor
0x23f mov  r0,#$30 // is this the event count for "bad MAP sensor"?
0x241 call $032A
0x243 mov  r0,#$2E
0x245 mov  a,@r0
0x246 add  a,#$72
0x248 jc   $024C
0x24a mov  @r1,#$12
0x24c mov  a,@r0
0x24d add  a,#$6B
0x24f jnc  $025A
0x251 mov  a,@r1
0x252 xrl  a,#$12
0x254 jnz  $025A
0x256 mov  @r1,a
0x257 mov  r0,#$3A
0x259 mov  @r0,a
0x25a mov  r0,#$41
0x25c mov  a,@r0
0x25d clr  c
0x25e jnz  $0262
0x260 call $02B1  // reset the boost error event counter 35h to the value 64h (100)
0x262 mov  r0,#$60 // load boost error location 60h into r0
0x264 mov  a,@r0 // load actual boost error into a
0x265 mov  r2,#$32 // BCD value for "boost too high"
0x267 jb7  $027B // boost error is 1's comp. so bit7=overboost
0x269 mov  r0,#$44 // 44h contains rpm axis
0x26b mov  a,@r0 // load rpm axis value into a
0x26c add  a,#$DB // add 219
0x26e jnc  $0272 // c=0 if rpm is > ~2800
0x270 call $02B1 // this resets 35h to the value 64h (100), so no event count for underboost at low rpm
0x272 mov  r0,#$60 // r0 now points to boost error location again
0x274 mov  a,@r0 // load boost error into a
0x275 dec  r2 // r2 now=31h, BCD value for "boost too low"
0x276 cpl  a
0x277 add  a,#$20 // add 32 (i.e. subtract 32 because we just cpl'd)
0x279 jc   $027D // c=1 means the boost error was < 32
0x27b add  a,#$20 // jmp to here if overboost (from 0x267), with a=boost error from 60h. We also get here if the previous -32 operation didn't carry, i.e. the underboost error was >=32.
0x27d cpl  c // for underboost, c=1 if the error was < 64. For overboost, c=1 if the error was > 32
0x27e mov  r0,#$6C // set in ADC MAP read. Used to rate limit updates to 52h (current measured boost),
                   // and rate limits error checking to 1/4 on rising boost
0x280 mov  a,@r0
0x281 jnz  $0289 // skip to the next test if boost error checking is being rate limited by 6Ch
0x283 mov  r0,#$35 // here, r0 is an input parameter to a generic event counter routine
0x285 mov  a,#$64
0x287 call $032C // error counter routine. c=0 no error. c=1, we have an error
 0x289 mov  r0,#$3C // next test, throttle position
 0x28b mov  a,#$F4
 0x28d add  a,@r0
 0x28e cpl  c
 0x28f mov  r2,#$41 // BCD code for TPS power
 0x291 jc   $0298 // if raw_tps < 12 then jump
 0x293 mov  a,#$24
 0x295 add  a,@r0
 0x296 inc  r2 // BCD code for TPS signal
 0x297 mov  a,@r0
 0x298 mov  @r0,a
 0x299 mov  r0,#$36
 0x29b call $032A
0x29d sel  mb1
0x29e call $0500
0x2a0 sel  mb0
0x2a1 call $0336
// END of blink code calculation

// stack manipulation for housekeeping functions
// See page 2-5 of the MCS-48 pdf. Locations 16h and 17h are the top
// of the stack (2-byte value).
// We got here from the reset purely by jumping, no calls.
// Thus the ret statement at 0x2B0 will use whatever we put on the stack  // in this routine below.
0x2a3 mov  r1,#$17
0x2a5 mov  @r1,#$8 // 17h <- 8 (locations will be 8xxh)
0x2a7 dec  r1
0x2a8 clr  a
0x2a9 xch  a,@r1 // a <- 16h and 16h <- 0
0x2aa jb0  $02AF // call the first function 0x800?
0x2ac dec  a
0x2ad dec  a
0x2ae xchd a,@r1
0x2af sel  mb1
0x2b0 ret
0x2b1 mov  r0,#$35
0x2b3 mov  @r0,#$64
0x2b5 ret

// BIG GAP
0x2fe movp a,@a
0x2ff ret

// 8-bit multiply function (r3 x r6), 16-bit result in a:r3
0x300 mov  r5,#$9    
0x302 clr  c                                             
0x303 clr  a         
0x304 rrc  a         
0x305 xch  a,r3      
0x306 rrc  a         
0x307 xch  a,r3      
0x308 jnc  $030B     
0x30a add  a,r6      
0x30b djnz r5,$0304
0x30d ret
// END of 8-bit multiply function

// main body of ext int routine
0x30e mov  @r0,a
0x30f mov  r0,#$25
0x311 mov  a,@r0
0x312 inc  a
0x313 mov  r2,a
0x314 mov  r0,#$21
0x316 mov  a,@r0
0x317 inc  a
0x318 mov  r3,a
0x319 mov  a,r7
0x31a swap a
0x31b cpl  a
0x31c add  a,#$A
0x31e mov  r0,a
0x31f djnz r0,$031F
0x321 mov  r0,#$38
0x323 mov  a,@r0
0x324 retr
// END ext int routine

// initialize r4 with ram[22h]
0x325 mov  r1,#$22
0x327 mov  a,@r1
0x328 mov  r4,a
0x329 ret
// END initialize r4 with ram[22h]

// Count errors and set 33h blink code
// We called into here from 0x22b. R0 was 0x30. Carry was set.
// mem[0x30] is a count we decrement.
0x32a mov  a,#$3C
0x32c xch  a,@r0  // mem[0x30] := 0x3c
0x32d jnc  $0331  // Not taken
0x32f dec  a      // a := 0x3b
0x330 mov  @r0,a // count is dec'd and stored back if c (error)
0x331 jnz  $0335 // just return if the error counter isn't 0 yet
0x333 mov  a,r2 // r2 should contain the BCD value for the error
0x334 mov  @r1,a // now the address in r1 (33h) has the error BCD
0x335 ret
// END count errors

// diagnostic function (unused?)
0x336 mov  r0,#$80
0x338 mov  r2,#$8
0x33a movx a,@r0     // On first execute of this instruction ADC channel 7 is selected
0x33b jb5  $0353
0x33d mov  r2,#$4
0x33f dec  r0
0x340 xch  a,@r0
0x341 swap a
0x342 xch  a,@r0
0x343 xchd a,@r0
0x344 djnz r2,$033F
0x346 jb6  $0352
0x348 jb7  $0352
0x34a inc  r0
0x34b mov  @r0,#$0
0x34d inc  r0
0x34e mov  a,@r0
0x34f anl  a,#$F
0x351 mov  @r0,a
0x352 ret
0x353 clr  f0
0x354 jb7  $0357
0x356 cpl  f0
0x357 mov  r3,#$7F
0x359 jb6  $0368
0x35b jb7  $0381
0x35d mov  r1,#$2C
0x35f mov  a,@r1
0x360 dec  a
0x361 rl   a
0x362 swap a
0x363 anl  a,#$3
0x365 add  a,r3
0x366 mov  r3,a
0x367 clr  f0
0x368 dec  r0
0x369 mov  a,r0
0x36a jb2  $037E
0x36c add  a,#$82
0x36e movp a,@a
0x36f mov  r3,#$7F
0x371 mov  r1,a
0x372 jf0  $0375
0x374 mov  a,@r1
0x375 mov  r4,a
0x376 mov  a,r3
0x377 add  a,r2
0x378 mov  r1,a
0x379 mov  a,r4
0x37a movx @r1,a
0x37b djnz r2,$0368
0x37d ret
0x37e mov  a,@r0
0x37f jmp  $0371
0x381 mov  r1,#$7D
0x383 mov  a,@r1
0x384 jnz  $039D
0x386 clr  f0
0x387 cpl  f0
0x388 call $0368
0x38a call $0390
0x38c mov  r0,#$7C
0x38e mov  @r0,a
0x38f ret
0x390 call $0392
0x392 mov  r0,#$7E
0x394 mov  r1,#$D
0x396 mov  a,@r0
0x397 xchd a,@r1
0x398 inc  r0
0x399 dec  r1
0x39a mov  a,@r0
0x39b mov  @r1,#$FE
0x39d ret
// END diagnostic function

// BIG GAP
0x3fa anl  a,#$60
0x3fc add  a,r0
0x3fd orl  a,@r1
0x3fe movp a,@a

0x3ff jmp  $040E

// ADC routine function address table
0x400 .db  0x0e
0x401 .db  0x3c
0x402 .db  0x3c
0x403 .db  0x3c
0x404 .db  0x27
0x405 .db  0x4c
0x406 .db  0x8c
0x407 .db  0x98
// END function table

// Random garbage?
0x408 .db  0x99
0x409 .db  0x8f
0x40a nop

// ADC routine jump. Jump to routine N, where N is read from the accumulator
0x40b anl  a,#$7
0x40d jmpp @a     // Reads contents of above table (that starts at 0x400) and writes it to the bottom byte of PC
// END ADC routine jmp

// ADC function #1 (address select)
0x40e anl  p1,#$F7 // Clear ALE. Result is ????_0???
0x410 mov  a,@r0
0x411 dec  a
0x412 jz   $041C
0x414 anl  p1,#$F3 // Clear MSB of ADC address. Result is ????_00??
0x416 jb4  $041A   // Jump if bit 4 of accumulator is set
0x418 anl  p1,#$F5 // Clear middle bit of ADC address. Result is ????_000?
0x41a jb3  $041E
0x41c anl  p1,#$F6 // Clear bottom bit of ADC address. Result is ????_0000
0x41e orl  p2,#$20 // Set bit 5 of port 2 - knock sensor integrator reset
0x420 orl  p1,#$8  // Set ADC ALE.
0x422 anl  p1,#$F5
0x424 orl  p1,#$5
0x426 ret
// END ADC function #1

// ADC function #3 (knock self-test)
0x427 mov  r0,#$23
0x429 mov  a,@r0
0x42a mov  r4,a
0x42b mov  r0,#$2F
0x42d mov  a,@r0
0x42e add  a,#$C0
0x430 mov  r0,#$31
0x432 jc   $0446
0x434 mov  a,@r0
0x435 jb2  $0438
0x437 ret
0x438 anl  a,#$7
0x43a mov  @r0,a
0x43b ret
// END ADC function #3

// ADC function #2 (knock self-test)
0x43c add  a,#$7
0x43e movp a,@a
0x43f mov  r0,#$2F
0x441 add  a,@r0
0x442 jc   $044B
0x444 mov  r0,#$31
0x446 mov  a,@r0
0x447 jnz  $044B
0x449 anl  p1,#$7F   // Clear fake knock signal
0x44b ret
// END ADC function #2

// ADC function #4 (read ADC ch. 0 - 3)
0x44c movx a,@r0
0x44d orl  p1,#$8    // OR with  0000_1000. Set ADC ALE.
0x44f anl  p1,#$F4   // AND with 1111_0100 -> Result is ????_0?00.
0x451 xch  a,@r0
0x452 jb4  $0480
0x454 jb3  $047B
0x456 xch  a,@r0
0x457 mov  r1,a
0x458 mov  a,@r0
0x459 xrl  a,#$6
0x45b mov  r0,#$2F // knock sensor noise
0x45d jz   $0476
0x45f mov  a,#$C0
0x461 add  a,r1
0x462 jnc  $0478
0x464 mov  a,r1
0x465 mov  @r0,a
0x466 mov  r1,#$34
0x468 mov  a,@r1
0x469 add  a,#$FA
0x46b jz   $0475
0x46d cpl  a
0x46e jz   $0472
0x470 mov  a,#$FC
0x472 add  a,#$69
0x474 mov  @r0,a
0x475 ret
0x476 mov  r0,#$2D
0x478 mov  a,r1
0x479 mov  @r0,a
0x47a ret
0x47b xch  a,@r0
0x47c mov  r0,#$2E // battery voltage
0x47e mov  @r0,a
0x47f ret

0x480 jb3  $0487
0x482 xch  a,@r0
0x483 mov  r0,#$6F
0x485 nop
0x486 ret
0x487 xch  a,@r0
0x488 mov  r0,#$39 // TPS v+ ?
0x48a mov  @r0,a
0x48b ret
// END ADC function #4

// ADC function #5 (read ch. 5 knock sensor)
// Andy - Manifold air pressure?
0x48c movx a,@r0
0x48d orl  p1,#$8
0x48f anl  p1,#$F7
0x491 orl  p1,#$7
0x493 mov  r0,#$46
0x495 cpl  a
0x496 mov  @r0,a
0x497 ret
// END ADC function #5

// ADC function #6 (MAP sensor?) Summary: read the ADC value, add 10 and
// compare it to the previous value to determine if boost is increasing or not.
// If it is increasing, then only update 52h and run boost error correction
// every 4th time. Otherwise, we keep the old value in 52h and run error
// checking every time. So boost has to be increasing for 4 cycles in a row to
// count as an increased value.
0x498 mov  r0,#$52
0x49a movx a,@r0
0x49b add  a,#$A // add 10 to the value from 52h
0x49d mov  r4,a // r4 <- value from 52h + 10
0x49e cpl  a
0x49f add  a,@r0
0x4a0 mov  r0,#$6C // used in blink code checking - we only trigger boost codes if this is 0
0x4a2 orl  p1,#$8 // latch or unlatch ALE?
0x4a4 anl  p1,#$F7 // select 11110111 (iow address ch.7, TPS angle for the nead read cycle)
0x4a6 jnc  $04B1 // c=0 if boost is increasing
0x4a8 mov  @r0,#$0 // here 6Ch is set to 0 which enables boost error code checking
0x4aa mov  r0,#$52
0x4ac mov  a,r4
0x4ad mov  @r0,a // store the value from r4 into 52h
0x4ae mov  r4,#$FF // r4 <- 255
0x4b0 ret
0x4b1 inc  @r0 // inc the value in 6Ch
0x4b2 mov  a,@r0
0x4b3 jb2  $04A8 // looks like we only enable error code checking every 4th read?
0x4b5 mov  r4,#$FF
0x4b7 ret
// END ADC function #6

// BIG GAP
0x4fe movp a,@a
0x4ff ret

// BIG GAP
0x5fe movp a,@a
0x5ff ret

// BIG GAP
0x6fe movp a,@a
0x6ff ret

// BIG GAP
0x7fe movp a,@a
0x7ff ret

// housekeeping function list (add 0x800h to calls)
0x800 call $020F // call throttle angle calculation? (A0E or A0F)
0x802 call $028D
0x804 call $0257
0x806 call $0282
0x808 nop
0x809 nop
0x80a call $029E // calculate ADC angles (A9E)
0x80c call $0100 // read maps (900)
0x80e nop
0x80f nop
0x810 call $0012
0x812 jmp  $0012
// END housekeeping function list

// BIG GAP
0x8fe movp a,@a
0x8ff ret

// read maps (rpm and PID gain)
0x900 mov  r1,#$44
0x902 mov  a,@r1
0x903 rl   a
0x904 swap a
0x905 anl  a,#$7
0x907 inc  a
0x908 mov  r5,a
0x909 mov  r2,#$25
0x90b mov  a,r2
0x90c movp a,@a
0x90d jz   $0919
0x90f mov  r1,a
0x910 mov  a,r2
0x911 add  a,#$9
0x913 xch  a,r2
0x914 add  a,r5
0x915 movp a,@a
0x916 mov  @r1,a
0x917 jmp  $010B
0x919 mov  r1,#$43
0x91b mov  a,@r1
0x91c anl  a,#$18
0x91e add  a,r2
0x91f add  a,r5
0x920 movp a,@a
0x921 mov  r1,#$6B
0x923 mov  @r1,a
0x924 ret
// END read maps

// RPM maps
0x925 .db  0x2A
0x926 .db  0x9B
0x927 .db  0x9B
0x928 .db  0x95
0x929 .db  0x92
0x92a .db  0x91
0x92b .db  0x8A
0x92c .db  0x83
0x92d .db  0x7F
0x92e .db  0x2B
0x92f .db  0x3D
0x930 .db  0x31
0x931 .db  0x30
0x932 .db  0x30
0x933 .db  0x30
0x934 .db  0x30
0x935 .db  0x30
0x936 .db  0x37
0x937 .db  0x47
0x938 .db  0x44
0x939 .db  0x44
0x93a .db  0x55
0x93b .db  0x66
0x93c .db  0x66
0x93d .db  0x66
0x93e .db  0x66
0x93f .db  0x66
0x940 .db  0x4A
0x941 .db  0x64
0x942 .db  0x50
0x943 .db  0x3E
0x944 .db  0x32
0x945 .db  0x24
0x946 .db  0x1C
0x947 .db  0x14
0x948 .db  0x0C
0x949 .db  0x50
0x94a .db  0x25
0x94b .db  0x1F
0x94c .db  0x1C
0x94d .db  0x19
0x94e .db  0x15
0x94f .db  0x12
0x950 .db  0x0F
0x951 .db  0x0C
0x952 .db  0x4E
0x953 .db  0x7D
0x954 .db  0x64
0x955 .db  0x51
0x956 .db  0x44
0x957 .db  0x38
0x958 .db  0x2B
0x959 .db  0x1F
0x95a .db  0x19
0x95b .db  0x4B
0x95c .db  0x12
0x95d .db  0x12
0x95e .db  0x12
0x95f .db  0x12
0x960 .db  0x12
0x961 .db  0x12
0x962 .db  0x12
0x963 .db  0x12
0x964 .db  0x48
0x965 .db  0x20
0x966 .db  0x20
0x967 .db  0x20
0x968 .db  0x1B
0x969 .db  0x1B
0x96a .db  0x1B
0x96b .db  0x19
0x96c .db  0x10
0x96d .db  0x4C
0x96e .db  0x80
0x96f .db  0x80
0x970 .db  0x80
0x971 .db  0x80
0x972 .db  0x80
0x973 .db  0x80
0x974 .db  0x80
0x975 .db  0x80
0x976 .db  0x3E
0x977 .db  0x42
0x978 .db  0x42
0x979 .db  0x42
0x97a .db  0x42
0x97b .db  0x42
0x97c .db  0x42
0x97d .db  0x42
0x97e .db  0x42
0x97f .db  0x45
0x980 .db  0x0A
0x981 .db  0x0A
0x982 .db  0x0A
0x983 .db  0x0A
0x984 .db  0x0A
0x985 .db  0x0A
0x986 .db  0x0A
0x987 .db  0x0A
0x988 .db  0x69
0x989 .db  0x04
0x98a .db  0x04
0x98b .db  0x04
0x98c .db  0x04
0x98d .db  0x04
0x98e .db  0x04
0x98f .db  0x04
0x990 .db  0x04
0x991 .db  0x00
// END rpm maps

// PID gain 8x4 map (rpm/throttle)
0x992 .db  0xE9
0x993 .db  0xE9
0x994 .db  0xE6
0x995 .db  0xE6
0x996 .db  0xEA
0x997 .db  0xE7
0x998 .db  0xE3
0x999 .db  0xE3
0x99a .db  0xC9
0x99b .db  0xA9
0x99c .db  0xA6
0x99d .db  0x86
0x99e .db  0x8A
0x99f .db  0xA7
0x9a0 .db  0xC3
0x9a1 .db  0xE3
0x9a2 .db  0xA9
0x9a3 .db  0x89
0x9a4 .db  0x86
0x9a5 .db  0x66
0x9a6 .db  0x6A
0x9a7 .db  0x67
0x9a8 .db  0x83
0x9a9 .db  0xE3
0x9aa .db  0xC9
0x9ab .db  0xA9
0x9ac .db  0x86
0x9ad .db  0x66
0x9ae .db  0x6A
0x9af .db  0x67
0x9b0 .db  0xA3
0x9b1 .db  0xE3
// PID gain 8x4 map

// BIG GAP
0x9fe movp a,@a
0x9ff ret

// RPM axis map
0xa00 .db  0x01
0xa01 .db  0x01
0xa02 .db  0x02
0xa03 .db  0x01
0xa04 .db  0x01
0xa05 .db  0x02
0xa06 .db  0x02
0xa07 .db  0x02
0xa08 .db  0x02
0xa09 .db  0x02
0xa0a .db  0x03
0xa0b .db  0x03
0xa0c .db  0x03
0xa0d .db  0x04
0xa0e .db  0x04 // added manually by me, see note below!
// END RPM axis map

// read throttle angle calculation.
// This was disassembled incorrectly.
// Location 0A0E = 04, this should be part of the map above
// location 0A0F = B9 = 1011 1001 = mov r1, XX
// location 0A10 = 3C, so we have "mov r1, 3C".
// location 0A11 = F1 = 1111 0001 = mov a, @r1

// 0xa0e jmp  $00B9
// 0xa10 movd p4,a

0xa0f mov  r1,#$3C // added manually by me, see note above
0xa11 mov  a,@r1
0xa12 cpl  a
0xa13 inc  r1
0xa14 add  a,@r1
0xa15 mov  r1,#$3F
0xa17 jc   $0A1F // c=1 if 3C > 3D (throttle increasing?)
0xa19 add  a,#$6
0xa1b jc   $0A1F // c=1 if 3C > 3D-6
0xa1d mov  @r1,#$B // 3F <- 11=0000 01011
0xa1f mov  a,@r1
0xa20 jz   $0A23
0xa22 dec  a
0xa23 anl  a,#$F
0xa25 mov  @r1,a
0xa26 mov  r1,#$3C // Read raw throttle pos sensor
0xa28 mov  a,@r1   // into a

0xa29 mov  r6,a
0xa2a dec  r1     // r1 now holds 3b, the address of a processed version of the TPS supply voltage
0xa2b mov  a,@r1
0xa2c mov  r3,a
0xa2d sel  mb0
0xa2e call $0300 // 8x8=16 multiply, so r3:a = 3Ch x 3Bh. 3B is initialized to 119 in the trigger routine.
0xa30 sel  mb1
0xa31 dec  r1    // r1 := 3a, the address of the throttle position in degrees
0xa32 mov  @r1,a // 3A <- high byte of the multiply
0xa33 add  a,#$CB // 203
0xa35 jc   $0A38
0xa37 clr  a
0xa38 mov  r1,#$43
0xa3a mov  @r1,a // 43h <- 3Ah + 203, or zero if 3Ah+203 < 255
0xa3b mov  a,#$E3 // 227
0xa3d add  a,@r1
0xa3e jnc  $0A42
0xa40 mov  @r1,#$1C // 43h <- 28 if 43h is >
0xa42 mov  r1,#$39
0xa44 mov  a,@r1
0xa45 mov  r6,a
0xa46 mov  r1,#$3B
0xa48 mov  a,@r1
0xa49 mov  r3,a
0xa4a sel  mb0
0xa4b call $0300 // r3:a = 39h x 3Bh (high byte)
0xa4d sel  mb1
0xa4e add  a,#$A3 // 163
0xa50 jz   $0A56
0xa52 cpl  a
0xa53 inc  a
0xa54 add  a,@r1
0xa55 mov  @r1,a
0xa56 ret
// END throttle angle calculation

// read rpm axis function
0xa57 mov  r1,#$44
0xa59 mov  r0,#$24
0xa5b mov  r6,#$0
0xa5d mov  a,@r0
0xa5e cpl  a
0xa5f mov  r4,a
0xa60 sel  rb0
0xa61 mov  a,r7
0xa62 sel  rb1
0xa63 cpl  a
0xa64 jb1  $0A7C
0xa66 cpl  a
0xa67 add  a,#$38
0xa69 add  a,r4
0xa6a mov  r4,a
0xa6b jc   $0A77
0xa6d inc  r6
0xa6e mov  a,r6
0xa6f rrc  a
0xa70 clr  c
0xa71 rrc  a
0xa72 movp a,@a
0xa73 add  a,r4
0xa74 mov  r4,a
0xa75 jnc  $0A6D
0xa77 mov  a,#$C4
0xa79 add  a,r6
0xa7a jnc  $0A7F
0xa7c mov  r6,#$3C
0xa7e clr  a
0xa7f xch  a,r6
0xa80 mov  @r1,a
0xa81 ret
// END read rpm axis function

// read CV feedforward map
0xa82 mov  r0,#$43
0xa84 mov  r1,#$44
0xa86 clr  f1
0xa87 call $0480
0xa89 mov  r1,#$68
0xa8b mov  @r1,a
0xa8c ret
// END read CV feedforward map

// read target boost map
0xa8d mov  r0,#$43
0xa8f mov  r1,#$44
0xa91 clr  f1
0xa92 cpl  f1
0xa93 call $0480
0xa95 cpl  a
0xa96 mov  r1,#$57
0xa98 add  a,@r1
0xa99 cpl  a
0xa9a mov  r1,#$51
0xa9c mov  @r1,a
0xa9d ret
// END read target boost map

// calculate ADC angles 1 & 2
0xa9e mov  r0,#$2A
0xaa0 mov  r1,#$22
0xaa2 call $0380
0xaa4 mov  @r1,a
0xaa5 mov  r0,#$2B
0xaa7 inc  r1
0xaa8 call $0380
0xaaa add  a,#$F8
0xaac mov  @r1,a
0xaad ret
// END calculate ADC angles

// BIG GAP
0xafe movp a,@a
0xaff ret

// CV feedforward aka open-loop map (rpm/throttle)
0xb00 .db   0x26
0xb01 .db   0x26
0xb02 .db   0x26
0xb03 .db   0x26
0xb04 .db   0x26
0xb05 .db   0x26
0xb06 .db   0x26
0xb07 .db   0x26
0xb08 .db   0x26
0xb09 .db   0x26
0xb0a .db   0x26
0xb0b .db   0x26
0xb0c .db   0x26
0xb0d .db   0x26
0xb0e .db   0x26
0xb0f .db   0x26
0xb10 .db   0x30
0xb11 .db   0x30
0xb12 .db   0x30
0xb13 .db   0x36
0xb14 .db   0x36
0xb15 .db   0x39
0xb16 .db   0x39
0xb17 .db   0x39
0xb18 .db   0x39
0xb19 .db   0x39
0xb1a .db   0x39
0xb1b .db   0x39
0xb1c .db   0x39
0xb1d .db   0x39
0xb1e .db   0x39
0xb1f .db   0x39
0xb20 .db   0x3A
0xb21 .db   0x3A
0xb22 .db   0x3D
0xb23 .db   0x43
0xb24 .db   0x45
0xb25 .db   0x49
0xb26 .db   0x49
0xb27 .db   0x4C
0xb28 .db   0x4C
0xb29 .db   0x4C
0xb2a .db   0x4C
0xb2b .db   0x4C
0xb2c .db   0x4C
0xb2d .db   0x4C
0xb2e .db   0x4C
0xb2f .db   0x4C
0xb30 .db   0x51
0xb31 .db   0x51
0xb32 .db   0x51
0xb33 .db   0x54
0xb34 .db   0x5A
0xb35 .db   0x60
0xb36 .db   0x64
0xb37 .db   0x68
0xb38 .db   0x6A
0xb39 .db   0x6C
0xb3a .db   0x6D
0xb3b .db   0x73
0xb3c .db   0x73
0xb3d .db   0x73
0xb3e .db   0x73
0xb3f .db   0x73
0xb40 .db   0x73
0xb41 .db   0x73
0xb42 .db   0x73
0xb43 .db   0x77
0xb44 .db   0x7B
0xb45 .db   0x7F
0xb46 .db   0x83
0xb47 .db   0x86
0xb48 .db   0x8A
0xb49 .db   0x8E
0xb4a .db   0x92
0xb4b .db   0x9A
0xb4c .db   0x9A
0xb4d .db   0x9A
0xb4e .db   0x9A
0xb4f .db   0x9A
0xb50 .db   0x96
0xb51 .db   0x92
0xb52 .db   0x8E
0xb53 .db   0x92
0xb54 .db   0x96
0xb55 .db   0x9D
0xb56 .db   0xA1
0xb57 .db   0xA5
0xb58 .db   0xA9
0xb59 .db   0xAD
0xb5a .db   0xB6
0xb5b .db   0xBF
0xb5c .db   0xBF
0xb5d .db   0xBF
0xb5e .db   0xBF
0xb5f .db   0xBF
0xb60 .db   0x96
0xb61 .db   0x92
0xb62 .db   0x8E
0xb63 .db   0x92
0xb64 .db   0x96
0xb65 .db   0x9D
0xb66 .db   0xA1
0xb67 .db   0xA5
0xb68 .db   0xA9
0xb69 .db   0xAD
0xb6a .db   0xB6
0xb6b .db   0xBF
0xb6c .db   0xBF
0xb6d .db   0xBF
0xb6e .db   0xBF
0xb6f .db   0xBF
0xb70 .db   0x96
0xb71 .db   0x92
0xb72 .db   0x8E
0xb73 .db   0x92
0xb74 .db   0x96
0xb75 .db   0x9D
0xb76 .db   0xA1
0xb77 .db   0xA5
0xb78 .db   0xA9
0xb79 .db   0xAD
0xb7a .db   0xB6
0xb7b .db   0xBF
0xb7c .db   0xBF
0xb7d .db   0xBF
0xb7e .db   0xBF
0xb7f .db   0xBF
// END CV feedforward map

// multiply @r0 by RPM value
0xb80 mov  a,@r0
0xb81 mov  r3,a
0xb82 mov  r0,#$24
0xb84 mov  a,@r0
0xb85 mov  r6,a
0xb86 sel  mb0
0xb87 call $0300
0xb89 sel  mb1
0xb8a ret
0xb8b jmp  $04FE
// END multiply @r0 by RPM

// BIG GAP
0xbfc jf1  $0B8B
0xbfe movp a,@a
0xbff ret

// target boost map (rpm/throttle)
0xc00 .db 0x98
0xc01 .db 0x98
0xc02 .db 0x98
0xc03 .db 0x96
0xc04 .db 0x96
0xc05 .db 0x96
0xc06 .db 0x94
0xc07 .db 0x94
0xc08 .db 0x94
0xc09 .db 0x92
0xc0a .db 0x92
0xc0b .db 0x91
0xc0c .db 0x91
0xc0d .db 0x90
0xc0e .db 0x8D
0xc0f .db 0x89
0xc10 .db 0x9E
0xc11 .db 0x9E
0xc12 .db 0x9E
0xc13 .db 0x9E
0xc14 .db 0x9E
0xc15 .db 0x9E
0xc16 .db 0x9E
0xc17 .db 0x9E
0xc18 .db 0x9E
0xc19 .db 0x9D
0xc1a .db 0x9D
0xc1b .db 0x9A
0xc1c .db 0x97
0xc1d .db 0x91
0xc1e .db 0x8D
0xc1f .db 0x8B
0xc20 .db 0xA5
0xc21 .db 0xA5
0xc22 .db 0xA5
0xc23 .db 0xA6
0xc24 .db 0xA7
0xc25 .db 0xA7
0xc26 .db 0xA7
0xc27 .db 0xAA
0xc28 .db 0xAA
0xc29 .db 0xA7
0xc2a .db 0xA7
0xc2b .db 0xA4
0xc2c .db 0x9D
0xc2d .db 0x94
0xc2e .db 0x8D
0xc2f .db 0x8B
0xc30 .db 0xAB
0xc31 .db 0xAB
0xc32 .db 0xAB
0xc33 .db 0xAE
0xc34 .db 0xAF
0xc35 .db 0xB0
0xc36 .db 0xB1
0xc37 .db 0xB4
0xc38 .db 0xB4
0xc39 .db 0xB4
0xc3a .db 0xB4
0xc3b .db 0xB1
0xc3c .db 0xAA
0xc3d .db 0x9F
0xc3e .db 0x8E
0xc3f .db 0x8D
0xc40 .db 0xB4
0xc41 .db 0xB4
0xc42 .db 0xB6
0xc43 .db 0xB8
0xc44 .db 0xBA
0xc45 .db 0xBC
0xc46 .db 0xBF
0xc47 .db 0xC1
0xc48 .db 0xC1
0xc49 .db 0xC1
0xc4a .db 0xC1
0xc4b .db 0xC1
0xc4c .db 0xBE
0xc4d .db 0xAB
0xc4e .db 0x91
0xc4f .db 0x8F
0xc50 .db 0xB9
0xc51 .db 0xB9
0xc52 .db 0xBC
0xc53 .db 0xC1
0xc54 .db 0xC6
0xc55 .db 0xCA
0xc56 .db 0xCE
0xc57 .db 0xCF
0xc58 .db 0xCF
0xc59 .db 0xD0
0xc5a .db 0xD1
0xc5b .db 0xD0
0xc5c .db 0xCE
0xc5d .db 0xB4
0xc5e .db 0x98
0xc5f .db 0x91
0xc60 .db 0xB9
0xc61 .db 0xB9
0xc62 .db 0xBC
0xc63 .db 0xC1
0xc64 .db 0xC6
0xc65 .db 0xCA
0xc66 .db 0xCE
0xc67 .db 0xCF
0xc68 .db 0xCF
0xc69 .db 0xD0
0xc6a .db 0xD1
0xc6b .db 0xD0
0xc6c .db 0xCE
0xc6d .db 0xB4
0xc6e .db 0x98
0xc6f .db 0x91
0xc70 .db 0xB9
0xc71 .db 0xB9
0xc72 .db 0xBC
0xc73 .db 0xC1
0xc74 .db 0xC6
0xc75 .db 0xCA
0xc76 .db 0xCE
0xc77 .db 0xCF
0xc78 .db 0xCF
0xc79 .db 0xD0
0xc7a .db 0xD1
0xc7b .db 0xD0
0xc7c .db 0xCE
0xc7d .db 0xB4
0xc7e .db 0x98
0xc7f .db 0x91

// 0xc80 mov  a,@r1
// END target boost map

// This must be incorrectly disassembled because 480 (C80) is called
// as the routine
// In any case this is where we call to from A82
// r0 = 43h
// r1 = 44h
// read boost/cv feedforward map
0xc80 mov  a,@r1 // added my me to fix the above mistake
0xc81 rrc  a
0xc82 rrc  a // divide 43h by 4 to get 0-7 range
0xc83 anl  a,#$F
0xc85 mov  r2,a
0xc86 mov  a,@r0
0xc87 rlc  a
0xc88 rlc  a
0xc89 anl  a,#$F0
0xc8b add  a,r2
0xc8c mov  r2,a
0xc8d mov  a,@r0
0xc8e anl  a,#$3
0xc90 inc  a
0xc91 dec  r0
0xc92 mov  @r0,a
0xc93 clr  a
0xc94 mov  r5,a
0xc95 mov  r7,a
0xc96 mov  r4,#$4
0xc98 mov  a,r4
0xc99 cpl  a
0xc9a add  a,@r0
0xc9b mov  a,r2
0xc9c jnc  $0CA0
0xc9e add  a,#$10
0xca0 mov  r3,a
0xca1 call $03FC
0xca3 add  a,r5
0xca4 mov  r5,a
0xca5 jnc  $0CA8
0xca7 inc  r7
0xca8 mov  a,@r1
0xca9 rrc  a
0xcaa mov  a,r3
0xcab jnc  $0CAE
0xcad inc  a
0xcae call $03FC
0xcb0 add  a,r5
0xcb1 mov  r5,a
0xcb2 jnc  $0CB5
0xcb4 inc  r7
0xcb5 mov  a,@r1
0xcb6 inc  r3
0xcb7 jb1  $0CBA
0xcb9 dec  r3
0xcba mov  a,r3
0xcbb call $03FC
0xcbd add  a,r5
0xcbe mov  r5,a
0xcbf jnc  $0CC2
0xcc1 inc  r7
0xcc2 mov  a,r3
0xcc3 call $03FC
0xcc5 add  a,r5
0xcc6 mov  r5,a
0xcc7 jnc  $0CCA
0xcc9 inc  r7
0xcca djnz r4,$0C98
0xccc mov  a,r7
0xccd anl  a,#$F
0xccf xch  a,r5
0xcd0 mov  r0,#$1D
0xcd2 xchd a,@r0
0xcd3 swap a
0xcd4 ret
// END read boost/cv feedforward map

// BIG GAP
0xcfe movp a,@a
0xcff ret

// Detect knock
0xd00 mov  r0,#$7A
0xd02 mov  r1,#$45
0xd04 mov  a,@r1
0xd05 cpl  a
0xd06 add  a,@r0
0xd07 jc   $0D0B
0xd09 mov  a,@r1
0xd0a mov  @r0,a
0xd0b mov  r1,#$47
0xd0d mov  r2,#$0
// The upper nibble of 47h represents 0-4 in steps of 0.25. The value in 7Ah is multipled by this // the values depend on rpm:
// low-medium: 66  (x1), medium-high: 55 (x0.75), high: 44 (x0.5). The final value is the threshold // the current reading must be *lower* than the threshold to count as knock // therefore this coefficient makes knock detection *less* sensitive at high rpm.
0xd0f mov  a,@r0
0xd10 mov  r0,a
0xd11 mov  r4,a
0xd12 rlc  a
0xd13 call $07C1 // 0xFC1
0xd15 call $07C1
0xd17 call $07BD // 0xFDB
0xd19 call $07BD
0xd1b mov  a,@r1
0xd1c swap a
0xd1d xchd a,@r1
0xd1e dec  r1
0xd1f mov  a,@r1
0xd20 cpl  a
0xd21 add  a,r4
0xd22 jc   $0D29
0xd24 mov  r2,#$9
0xd26 mov  a,@r1
0xd27 rrc  a
0xd28 mov  @r1,a

0xd29 mov  r0,#$73
0xd2b mov  r1,#$49
0xd2d mov  r3,#$4
0xd2f clr  f0
0xd30 cpl  f0
0xd31 call $0798
0xd33 mov  r0,#$6F
0xd35 mov  r3,#$4
0xd37 inc  r0
0xd38 xch  a,@r0
0xd39 djnz r3,$0D37
0xd3b mov  r1,#$3A
0xd3d mov  a,@r1
0xd3e mov  r5,a
0xd3f add  a,#$F0
0xd41 jc   $0D4B
0xd43 mov  r1,#$33
0xd45 mov  a,@r1
0xd46 add  a,#$EF
0xd48 jnz  $0D4B
0xd4a mov  @r1,a
0xd4b mov  r1,#$48
0xd4d mov  a,@r1
0xd4e cpl  a
0xd4f add  a,r5
0xd50 mov  r1,#$31
0xd52 mov  a,@r1
0xd53 mov  r7,a
0xd54 djnz r7,$0D74
0xd56 mov  @r1,#$2
0xd58 inc  r2
0xd59 mov  a,#$6
0xd5b mov  r0,#$34
0xd5d xch  a,@r0
0xd5e djnz r2,$0D62
0xd60 dec  a
0xd61 mov  @r0,a
0xd62 jnz  $0D68
0xd64 mov  r1,#$33
0xd66 mov  @r1,#$23
0xd68 mov  r0,#$7B
0xd6a mov  a,@r0
0xd6b mov  r3,a
0xd6c dec  r0
0xd6d mov  a,@r0
0xd6e mov  r6,#$74
0xd70 call $07AB
0xd72 jmp  $0589
0xd74 clr  a
0xd75 jnc  $0D7E
0xd77 mov  a,r2
0xd78 jz   $0D7C
0xd7a anl  p1,#$BF
0xd7c mov  a,@r0
0xd7d add  a,r2
0xd7e mov  @r0,a
0xd7f mov  r0,#$7A
0xd81 mov  r1,#$46
0xd83 mov  r6,#$74
0xd85 mov  r7,#$4
0xd87 call $07A9
0xd89 mov  r0,#$5E
0xd8b mov  r1,#$73
0xd8d mov  r6,#$58
0xd8f mov  r7,#$4
0xd91 call $07A9
0xd93 mov  r0,#$57
0xd95 mov  r1,#$2C
0xd97 mov  a,@r1
0xd98 anl  a,#$38
0xd9a mov  r4,a
0xd9b jnz  $0DA5
0xd9d mov  r1,#$4F
0xd9f mov  r3,#$1
0xda1 cpl  f0
0xda2 call $0798
0xda4 mov  @r0,a
0xda5 mov  r1,#$4C
0xda7 mov  a,@r1
0xda8 swap a
0xda9 cpl  a
0xdaa mov  r2,a
0xdab orl  a,#$F0
0xdad inc  a
0xdae mov  r1,#$58
0xdb0 add  a,@r1
0xdb1 jnc  $0DBA
0xdb3 jnz  $0DBA
0xdb5 inc  r1
0xdb6 mov  a,r2
0xdb7 orl  a,#$F
0xdb9 add  a,@r1
0xdba mov  r1,#$4D
0xdbc mov  a,@r1
0xdbd jf0  $0DC0
0xdbf inc  @r1
0xdc0 jnz  $0DCE
0xdc2 mov  @r1,a
0xdc3 jnc  $0DCE
0xdc5 mov  a,@r0
0xdc6 add  a,#$5
0xdc8 mov  @r0,a
0xdc9 inc  r1
0xdca mov  a,@r1
0xdcb cpl  a
0xdcc dec  r1
0xdcd mov  @r1,a
0xdce mov  r2,#$4D
0xdd0 mov  a,@r0
0xdd1 cpl  a
0xdd2 add  a,r2
0xdd3 jc   $0DD7
0xdd5 mov  a,r2
0xdd6 mov  @r0,a
0xdd7 mov  r0,#$6B
0xdd9 mov  a,r4
0xdda clr  f0
0xddb cpl  f0
0xddc jmp  $0600
// END detect knock

// filter target boost
0xdde mov  a,@r0
0xddf anl  a,#$3
0xde1 add  a,#$1
0xde3 mov  r6,a
0xde4 mov  r7,a
0xde5 mov  r0,#$53
0xde7 mov  r1,#$55
0xde9 call $05F1
0xdeb mov  a,r6
0xdec mov  r7,a
0xded mov  r0,#$55
0xdef mov  r1,#$51
0xdf1 call $0608
0xdf3 mov  @r0,a
0xdf4 inc  r0
0xdf5 xch  a,r3
0xdf6 mov  @r0,a
0xdf7 ret
// END filter target boost

0xdf8 nop
0xdf9 nop
0xdfa nop
0xdfb nop
0xdfc nop
0xdfd nop
0xdfe movp a,@a
0xdff ret

// select PID function
0xe00 jb4  $0E82
0xe02 jb3  $0E30
0xe04 nop
0xe05 nop
0xe06 jmp  $05DE
// END select PID function

// exponential smoothing function
0xe08 mov  a,r7
0xe09 mov  r4,a
0xe0a mov  a,@r0
0xe0b mov  r2,a
0xe0c inc  r0
0xe0d mov  a,@r0
0xe0e mov  r3,a
0xe0f call $07CB
0xe11 mov  a,r4
0xe12 mov  r7,a
0xe13 mov  a,r3
0xe14 cpl  a
0xe15 add  a,#$1
0xe17 mov  r5,a
0xe18 mov  a,r2
0xe19 cpl  a
0xe1a addc a,#$0
0xe1c mov  r4,a
0xe1d mov  a,@r1
0xe1e mov  r2,a
0xe1f mov  r3,#$0
0xe21 call $07CB
0xe23 mov  a,@r0
0xe24 add  a,r5
0xe25 mov  r5,a
0xe26 dec  r0
0xe27 mov  a,@r0
0xe28 addc a,r4
0xe29 mov  r4,a
0xe2a mov  a,r5
0xe2b add  a,r3
0xe2c mov  r3,a
0xe2d mov  a,r4
0xe2e addc a,r2
0xe2f ret
// END exponential smoothing function

// PID derivative function. Location 52h contains actual boost and 51h contains target boost (from the map read routine). Here they are compared for the error value. At 0xe38, carry is set if actual boost was higher than target, i.e. overboost.
0xe30 mov  r1,#$52
0xe32 mov  a,@r1
0xe33 cpl  a
0xe34 dec  r1
0xe35 add  a,@r1
0xe36 mov  r1,#$64
0xe38 jnc  $0E56
0xe3a mov  r2,a
0xe3b cpl  a
0xe3c add  a,@r1
0xe3d mov  a,@r1
0xe3e jnz  $0E47
0xe40 inc  r1
0xe41 mov  a,@r1
0xe42 dec  r1
0xe43 jnz  $0E4B
0xe45 mov  a,r2
0xe46 mov  @r1,a
0xe47 mov  a,r2
0xe48 jc   $0E4B
0xe4a mov  @r1,a
0xe4b clr  c
0xe4c rlc  a
0xe4d jc   $0E58
0xe4f rlc  a
0xe50 jc   $0E58
0xe52 cpl  a
0xe53 add  a,@r1
0xe54 jnc  $0E58
0xe56 mov  @r1,#$0
0xe58 mov  a,@r1
0xe59 jz   $0E73
0xe5b mov  r0,#$6B
0xe5d mov  a,@r0
0xe5e rr   a
0xe5f rr   a
0xe60 anl  a,#$3
0xe62 add  a,#$1
0xe64 mov  r7,a
0xe65 mov  r0,#$65
0xe67 mov  a,@r0
0xe68 cpl  a
0xe69 inc  a
0xe6a add  a,@r1
0xe6b clr  c
0xe6c rrc  a
0xe6d clr  c
0xe6e rlc  a
0xe6f jb7  $0E7E
0xe71 djnz r7,$0E6E
0xe73 add  a,#$80
0xe75 mov  r0,#$62
0xe77 mov  @r0,a
0xe78 mov  r7,#$6
0xe7a mov  r0,#$65
0xe7c jmp  $05F1
0xe7e mov  a,#$7F
0xe80 jmp  $0673
// END PID derivative function

// PID proportional/integral function
0xe82 jb3  $0EF6
0xe84 mov  r1,#$52
0xe86 mov  a,@r1
0xe87 cpl  a
0xe88 inc  r1
0xe89 add  a,@r1
0xe8a mov  r4,a
0xe8b jc   $0E8F
0xe8d cpl  f0
0xe8e cpl  a
0xe8f add  a,#$FC
0xe91 mov  r1,#$6A
0xe93 mov  r0,#$61
0xe95 jc   $0E9B
0xe97 mov  a,@r1
0xe98 inc  @r1
0xe99 jnz  $0ED0
0xe9b dec  r1
0xe9c mov  a,@r1
0xe9d cpl  a
0xe9e inc  r1
0xe9f mov  @r1,a
0xea0 inc  @r0
0xea1 jf0  $0EA7
0xea3 mov  a,@r0
0xea4 add  a,#$FE
0xea6 mov  @r0,a
0xea7 mov  r1,#$62
0xea9 mov  a,@r1
0xeaa add  a,#$60
0xeac jnc  $0EB0
0xeae mov  @r0,#$80
0xeb0 mov  a,#$BB
0xeb2 mov  r3,a
0xeb3 cpl  a
0xeb4 add  a,@r0
0xeb5 jc   $0EBE
0xeb7 mov  a,#$44
0xeb9 mov  r3,a
0xeba cpl  a
0xebb add  a,@r0
0xebc jc   $0ED0
0xebe mov  r1,#$67
0xec0 mov  a,@r1
0xec1 jnz  $0EC5
0xec3 clr  c
0xec4 cpl  c
0xec5 cpl  a
0xec6 jz   $0EC9
0xec8 inc  @r1
0xec9 jc   $0ECE
0xecb cpl  a
0xecc dec  a
0xecd mov  @r1,a
0xece mov  a,r3
0xecf mov  @r0,a
0xed0 mov  r1,#$6B
0xed2 mov  a,@r1
0xed3 jb4  $0ED9
0xed5 mov  a,r4
0xed6 clr  c
0xed7 rrc  a
0xed8 mov  r4,a
0xed9 mov  a,r4
0xeda clr  c
0xedb rlc  a
0xedc mov  r4,a
0xedd jb7  $0EE5
0xedf add  a,#$C0
0xee1 jnc  $0EE5
0xee3 mov  r4,#$40
0xee5 mov  a,r4
0xee6 mov  r1,#$60
0xee8 mov  @r1,a
0xee9 add  a,@r0
0xeea inc  r0
0xeeb add  a,@r0
0xeec inc  r0
0xeed jnc  $0EF1
0xeef jb7  $0EF3
0xef1 mov  @r0,a
0xef2 ret
0xef3 mov  @r0,#$7F
0xef5 ret
0xef6 jmp  $0700
// END PID proportional/integral function

0xef8 nop
0xef9 nop
0xefa nop
0xefb nop
0xefc nop
0xefd nop
0xefe movp a,@a
0xeff ret

// final CV output calculation
0xf00 mov  r1,#$63
0xf02 mov  a,@r1
0xf03 mov  r6,a
0xf04 cpl  a
0xf05 jb7  $0F0A
0xf07 inc  a
0xf08 mov  r6,a
0xf09 cpl  f0
0xf0a mov  a,@r0
0xf0b orl  a,#$1F
0xf0d mov  r3,a
0xf0e sel  mb0
0xf0f call $0300
0xf11 sel  mb1
0xf12 mov  r3,#$B1
0xf14 jf0  $0F19
0xf16 cpl  a
0xf17 mov  r3,#$0
0xf19 mov  r4,a
0xf1a mov  r1,#$67
0xf1c mov  a,@r1
0xf1d clr  c
0xf1e rlc  a
0xf1f mov  r1,#$68
0xf21 add  a,@r1
0xf22 mov  r1,#$6F
0xf24 mov  @r1,a
0xf25 add  a,r4
0xf26 mov  r4,a
0xf27 jf0  $0F2A
0xf29 cpl  c
0xf2a jc   $0F33
0xf2c cpl  a
0xf2d add  a,r3
0xf2e jf0  $0F31
0xf30 cpl  c
0xf31 jc   $0F3F
0xf33 mov  a,r3
0xf34 mov  r4,a
0xf35 mov  r1,#$67
0xf37 mov  a,@r1
0xf38 dec  a
0xf39 dec  a
0xf3a jb7  $0F3E
0xf3c add  a,#$4
0xf3e mov  @r1,a
0xf3f mov  r2,#$22
0xf41 call $07D5
0xf43 mov  r1,#$43
0xf45 mov  a,@r1
0xf46 jz   $0F81
0xf48 add  a,#$FF
0xf4a jc   $0F4F
0xf4c mov  a,@r0
0xf4d jz   $0F81
0xf4f inc  r1
0xf50 mov  a,@r1
0xf51 add  a,#$C4
0xf53 jc   $0F81
0xf55 add  a,#$0
0xf57 jnc  $0F5C
0xf59 mov  a,@r0
0xf5a jz   $0F81
0xf5c mov  r1,#$4B
0xf5e mov  a,@r1
0xf5f mov  r2,a
0xf60 mov  r1,#$33 // 33h is current blink code
0xf62 mov  a,@r1
0xf63 jz   $0F69
0xf65 add  a,#$EF // EFh+11h=0
0xf67 jnz  $0F81
0xf69 mov  a,r4
0xf6a mov  @r0,a
0xf6b mov  r0,#$6F
0xf6d mov  r4,#$4
0xf6f inc  r0
0xf70 mov  a,@r0
0xf71 cpl  a
0xf72 add  a,r2
0xf73 jc   $0F7E
0xf75 mov  a,r2
0xf76 mov  @r0,a
0xf77 mov  r1,#$33
0xf79 mov  a,@r1
0xf7a jnz  $0F7E
0xf7c mov  @r1,#$11 // 33h <- 11 (blink code 1-1)
0xf7e djnz r4,$0F6F
0xf80 ret
// END cv final output calculation

// limp mode function
0xf81 clr  a
0xf82 mov  r3,#$10
0xf84 mov  r1,#$57
0xf86 mov  @r1,a
0xf87 inc  r1
0xf88 djnz r3,$0F86
0xf8a mov  @r1,#$80
0xf8c mov  r1,#$61
0xf8e mov  @r1,#$80
0xf90 mov  r1,#$52
0xf92 mov  a,@r1
0xf93 inc  r1
0xf94 mov  @r1,a
0xf95 clr  a
0xf96 jmp  $076A
// END limp mode function

// count cycles for cylinders
0xf98 inc  @r1
0xf99 mov  a,@r1
0xf9a jnz  $0FA1
0xf9c inc  r1
0xf9d mov  a,@r1
0xf9e cpl  a
0xf9f dec  r1
0xfa0 mov  @r1,a
0xfa1 add  a,r3
0xfa2 mov  a,@r0
0xfa3 jnc  $0FA8
0xfa5 jz   $0FA8
0xfa7 dec  a
0xfa8 ret
// end count cycles

// call exp. smoothing and rotate 16-bit values
0xfa9 call $0608
0xfab call $07B0
0xfad call $07B0
0xfaf ret
0xfb0 xch  a,r6
0xfb1 mov  r0,a
0xfb2 xch  a,r6
0xfb3 xch  a,r3
0xfb4 mov  r7,#$4
0xfb6 xch  a,@r0
0xfb7 inc  r0
0xfb8 xch  a,@r0
0xfb9 inc  r0
0xfba djnz r7,$0FB6
0xfbc ret

0xfbd mov  a,r0
0xfbe clr  c
0xfbf rrc  a
0xfc0 mov  r0,a
0xfc1 xch  a,@r1
0xfc2 rlc  a
0xfc3 xch  a,@r1
0xfc4 jnc  $0FC9
0xfc6 add  a,r4
0xfc7 xch  a,r4
0xfc8 ret
0xfc9 mov  a,r0
0xfca ret
0xfcb mov  a,r2
0xfcc clr  c
0xfcd rrc  a
0xfce mov  r2,a
0xfcf mov  a,r3
0xfd0 rrc  a
0xfd1 mov  r3,a
0xfd2 djnz r7,$0FCB
0xfd4 ret
// end call exp. smoothing/rotate values

// prep CV output
0xfd5 mov  r0,#$41
0xfd7 mov  a,r4
0xfd8 add  a,#$40
0xfda jnc  $0FDE
0xfdc mov  r4,#$BF
0xfde ret
// end prep CV output

// BIG GAP
0xff5 jb1  $0F32
0xff7 jb1  $0F43
0xff9 orl  a,#$43
0xffb jb1  $0F32
0xffd jb1  $0F20
0xfff dis  i
